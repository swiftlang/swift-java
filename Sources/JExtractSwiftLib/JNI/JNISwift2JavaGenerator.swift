//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import JavaTypes

package class JNISwift2JavaGenerator: Swift2JavaGenerator {
  let analysis: AnalysisResult
  let swiftModuleName: String
  let javaPackage: String
  let logger: Logger
  let swiftOutputDirectory: String
  let javaOutputDirectory: String

  var javaPackagePath: String {
    javaPackage.replacingOccurrences(of: ".", with: "/")
  }

  var thunkNameRegistry = ThunkNameRegistry()

  /// Because we need to write empty files for SwiftPM, keep track which files we didn't write yet,
  /// and write an empty file for those.
  var expectedOutputSwiftFiles: Set<String>

  package init(
    translator: Swift2JavaTranslator,
    javaPackage: String,
    swiftOutputDirectory: String,
    javaOutputDirectory: String
  ) {
    self.logger = Logger(label: "jni-generator", logLevel: translator.log.logLevel)
    self.analysis = translator.result
    self.swiftModuleName = translator.swiftModuleName
    self.javaPackage = javaPackage
    self.swiftOutputDirectory = swiftOutputDirectory
    self.javaOutputDirectory = javaOutputDirectory

     // If we are forced to write empty files, construct the expected outputs
    if translator.config.writeEmptyFiles ?? false {
      self.expectedOutputSwiftFiles = Set(translator.inputs.compactMap { (input) -> String? in
        guard let filePathPart = input.filePath.split(separator: "/\(translator.swiftModuleName)/").last else {
          return nil
        }

        return String(filePathPart.replacing(".swift", with: "+SwiftJava.swift"))
      })
      self.expectedOutputSwiftFiles.insert("\(translator.swiftModuleName)Module+SwiftJava.swift")
    } else {
      self.expectedOutputSwiftFiles = []
    }
  }

  func generate() throws {
    try writeSwiftThunkSources()
    try writeExportedJavaSources()

    let pendingFileCount = self.expectedOutputSwiftFiles.count
    if pendingFileCount > 0 {
      print("[swift-java] Write empty [\(pendingFileCount)] 'expected' files in: \(swiftOutputDirectory)/")
      try writeSwiftExpectedEmptySources()
    }
  }
}

extension JNISwift2JavaGenerator {
  func writeExportedJavaSources() throws {
    var printer = CodePrinter()
    try writeExportedJavaSources(&printer)
  }

  package func writeExportedJavaSources(_ printer: inout CodePrinter) throws {
    let filename = "\(self.swiftModuleName).java"
    logger.trace("Printing module class: \(filename)")
    printModule(&printer)

    if let outputFile = try printer.writeContents(
      outputDirectory: javaOutputDirectory,
      javaPackagePath: javaPackagePath,
      filename: filename
    ) {
      logger.info("[swift-java] Generated: \(self.swiftModuleName).java (at \(outputFile))")
    }
  }

  func writeSwiftThunkSources() throws {
    var printer = CodePrinter()
    try writeSwiftThunkSources(&printer)
  }

  package func writeSwiftExpectedEmptySources() throws {
    for expectedFileName in self.expectedOutputSwiftFiles {
      logger.trace("Write empty file: \(expectedFileName) ...")

      var printer = CodePrinter()
      printer.print("// Empty file generated on purpose")
      _ = try printer.writeContents(
        outputDirectory: self.swiftOutputDirectory,
        javaPackagePath: nil,
        filename: expectedFileName)
    }
  }

  package func writeSwiftThunkSources(_ printer: inout CodePrinter) throws {
    let moduleFilenameBase = "\(self.swiftModuleName)Module+SwiftJava"
    let moduleFilename = "\(moduleFilenameBase).swift"

    do {
      logger.trace("Printing swift module class: \(moduleFilename)")

      try printGlobalSwiftThunkSources(&printer)

      if let outputFile = try printer.writeContents(
        outputDirectory: self.swiftOutputDirectory,
        javaPackagePath: nil,
        filename: moduleFilename
      ) {
        print("[swift-java] Generated: \(moduleFilenameBase.bold).swift (at \(outputFile))")
        self.expectedOutputSwiftFiles.remove(moduleFilename)
      }
    } catch {
      logger.warning("Failed to write to Swift thunks: \(moduleFilename)")
    }
  }
}

extension JNISwift2JavaGenerator {
  private func printGlobalSwiftThunkSources(_ printer: inout CodePrinter) throws {
    printer.print(
      """
      // Generated by swift-java

      import JavaKit

      """)

    for decl in analysis.importedGlobalFuncs {
      printSwiftFunctionThunk(&printer, decl)
      printer.println()
    }
  }

  private func printSwiftFunctionThunk(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    // TODO: Replace swiftModuleName with class name if non-global
    let cName =
      "Java_" + self.javaPackage.replacingOccurrences(of: ".", with: "_") + "_\(swiftModuleName)_"
      + decl.name
    let thunkName = thunkNameRegistry.functionThunkName(decl: decl)
    let translatedParameters = decl.functionSignature.parameters.enumerated().map { idx, param in
      (param.parameterName ?? "arg\(idx)", param.type.javaType)
    }

    let thunkParameters =
      [
        "environment: UnsafeMutablePointer<JNIEnv?>!",
        "thisClass: jclass",
      ] + translatedParameters.map { "\($0.0): \($0.1.jniTypeName)" }
    let swiftReturnType = decl.functionSignature.result.type
    let thunkReturnType =
      !swiftReturnType.isVoid ? " -> \(swiftReturnType.javaType.jniTypeName)" : ""

    printer.printBraceBlock(
      """
      @_cdecl("\(cName)")
      func \(thunkName)(\(thunkParameters.joined(separator: ", ")))\(thunkReturnType)
      """
    ) { printer in
      let downcallParameters = zip(decl.functionSignature.parameters, translatedParameters).map {
        originalParam, translatedParam in
        let label = originalParam.argumentLabel.map { "\($0): " } ?? ""
        return "\(label)\(originalParam.type)(fromJNI: \(translatedParam.0), in: environment!)"
      }
      let tryClause: String = decl.isThrowing ? "try " : ""
      let functionDowncall =
        "\(tryClause)\(swiftModuleName).\(decl.name)(\(downcallParameters.joined(separator: ", ")))"

      let innerBody =
        if swiftReturnType.isVoid {
          functionDowncall
        } else {
          """
          let result = \(functionDowncall)
          return result.getJNIValue(in: environment)
          """
        }

      if decl.isThrowing {
        let dummyReturn =
          !swiftReturnType.isVoid ? "return \(swiftReturnType).jniPlaceholderValue" : ""
        printer.print(
          """
          do {
            \(innerBody)
          } catch {
            environment.throwAsException(error)
            \(dummyReturn)
          }
          """
        )
      } else {
        printer.print(innerBody)
      }
    }
  }
}

extension JNISwift2JavaGenerator {
  private func printModule(_ printer: inout CodePrinter) {
    printHeader(&printer)
    printPackage(&printer)

    printModuleClass(&printer) { printer in
      printer.print(
        """
        static final String LIB_NAME = "\(swiftModuleName)";
        
        static {
          System.loadLibrary(LIB_NAME);
        }
        """
      )

      for decl in analysis.importedGlobalFuncs {
        self.logger.trace("Print global function: \(decl)")
        printFunctionBinding(&printer, decl)
        printer.println()
      }
    }
  }

  private func printHeader(_ printer: inout CodePrinter) {
    printer.print(
      """
      // Generated by jextract-swift
      // Swift module: \(swiftModuleName)

      """
    )
  }

  private func printPackage(_ printer: inout CodePrinter) {
    printer.print(
      """
      package \(javaPackage);

      """
    )
  }

  private func printModuleClass(_ printer: inout CodePrinter, body: (inout CodePrinter) -> Void) {
    printer.printBraceBlock("public final class \(swiftModuleName)") { printer in
      body(&printer)
    }
  }

  private func printFunctionBinding(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    let returnType = decl.functionSignature.result.type.javaType
    let params = decl.functionSignature.parameters.enumerated().map { idx, param in
      "\(param.type.javaType) \(param.parameterName ?? "arg\(idx))")"
    }
    let throwsClause = decl.isThrowing ? " throws Exception" : ""

    printer.print(
      """
      /**
      * Downcall to Swift:
      * {@snippet lang=swift :
      * \(decl.signatureString)
      * }
      */
      """
    )
    printer.print(
      "public static native \(returnType) \(decl.name)(\(params.joined(separator: ", ")))\(throwsClause);"
    )
  }
}

extension SwiftType {
  var javaType: JavaType {
    switch self {
    case .nominal(let nominalType):
      if let knownType = nominalType.nominalTypeDecl.knownStandardLibraryType {
        guard let javaType = knownType.javaType else {
          fatalError("unsupported known type: \(knownType)")
        }
        return javaType
      }

      fatalError("unsupported nominal type: \(nominalType)")

    case .tuple([]):
      return .void

    case .metatype, .optional, .tuple, .function:
      fatalError("unsupported type: \(self)")
    }
  }
}

extension SwiftStandardLibraryTypeKind {
  var javaType: JavaType? {
    switch self {
    case .bool: .boolean
    case .int: .long  // TODO: Handle 32-bit or 64-bit
    case .int8: .byte
    case .uint16: .char
    case .int16: .short
    case .int32: .int
    case .int64: .long
    case .float: .float
    case .double: .double
    case .void: .void
    case .string: .javaLangString
    case .uint, .uint8, .uint32, .uint64,
      .unsafeRawPointer, .unsafeMutableRawPointer,
      .unsafePointer, .unsafeMutablePointer,
      .unsafeRawBufferPointer, .unsafeMutableRawBufferPointer,
      .unsafeBufferPointer, .unsafeMutableBufferPointer:
      nil
    }
  }
}
