//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import JavaTypes

// MARK: Defaults

extension JNISwift2JavaGenerator {
  /// Default set Java imports for every generated file
  static let defaultJavaImports: Array<String> = [
    "org.swift.swiftkit.core.*",
    "org.swift.swiftkit.core.util.*",
    "java.util.*",

    // NonNull, Unsigned and friends
    "org.swift.swiftkit.core.annotations.*",
  ]
}

// MARK: Printing

extension JNISwift2JavaGenerator {
  func writeExportedJavaSources() throws {
    var printer = CodePrinter()
    try writeExportedJavaSources(&printer)
  }

  package func writeExportedJavaSources(_ printer: inout CodePrinter) throws {
    let importedTypes = analysis.importedTypes.sorted(by: { (lhs, rhs) in lhs.key < rhs.key })

    for (_, ty) in importedTypes {
      let filename = "\(ty.swiftNominal.name).java"
      logger.debug("Printing contents: \(filename)")
      printImportedNominal(&printer, ty)

      if let outputFile = try printer.writeContents(
        outputDirectory: javaOutputDirectory,
        javaPackagePath: javaPackagePath,
        filename: filename
      ) {
        logger.info("[swift-java] Generated: \(ty.swiftNominal.name.bold).java (at \(outputFile))")
      }
    }

    let filename = "\(self.swiftModuleName).java"
    logger.trace("Printing module class: \(filename)")
    printModule(&printer)

    if let outputFile = try printer.writeContents(
      outputDirectory: javaOutputDirectory,
      javaPackagePath: javaPackagePath,
      filename: filename
    ) {
      logger.info("[swift-java] Generated: \(self.swiftModuleName).java (at \(outputFile))")
    }
  }

  private func printModule(_ printer: inout CodePrinter) {
    printHeader(&printer)
    printPackage(&printer)
    printImports(&printer)

    printModuleClass(&printer) { printer in
      printer.print(
        """
        static final String LIB_NAME = "\(swiftModuleName)";
        
        static {
          System.loadLibrary(LIB_NAME);
        }
        """
      )

      for decl in analysis.importedGlobalFuncs {
        self.logger.trace("Print global function: \(decl)")
        printFunctionDowncallMethods(&printer, decl)
        printer.println()
      }

      for decl in analysis.importedGlobalVariables {
        self.logger.trace("Print global variable: \(decl)")
        printFunctionDowncallMethods(&printer, decl)
        printer.println()
      }
    }
  }

  private func printImportedNominal(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    printHeader(&printer)
    printPackage(&printer)
    printImports(&printer)

    printNominal(&printer, decl) { printer in
      printer.print(
        """
        static final String LIB_NAME = "\(swiftModuleName)";
        
        @SuppressWarnings("unused")
        private static final boolean INITIALIZED_LIBS = initializeLibs();
        static boolean initializeLibs() {
            System.loadLibrary(LIB_NAME);
            return true;
        }
        """
      )

      printer.print(
        """
        public \(decl.swiftNominal.name)(long selfPointer, SwiftArena swiftArena) {
          super(selfPointer, swiftArena);
        }
        """
      )

      printer.println()

      if decl.swiftNominal.kind == .enum {
        printEnumHelpers(&printer, decl)
        printer.println()
      }

      for initializer in decl.initializers {
        printFunctionDowncallMethods(&printer, initializer)
        printer.println()
      }

      for method in decl.methods {
        printFunctionDowncallMethods(&printer, method)
        printer.println()
      }

      for variable in decl.variables {
        printFunctionDowncallMethods(&printer, variable)
        printer.println()
      }

      printDestroyFunction(&printer, decl)
    }
  }

  private func printHeader(_ printer: inout CodePrinter) {
    printer.print(
      """
      // Generated by jextract-swift
      // Swift module: \(swiftModuleName)

      """
    )
  }

  private func printPackage(_ printer: inout CodePrinter) {
    printer.print(
      """
      package \(javaPackage);

      """
    )
  }

  private func printImports(_ printer: inout CodePrinter) {
    for i in JNISwift2JavaGenerator.defaultJavaImports {
      printer.print("import \(i);")
    }
    printer.print("")
  }

  private func printNominal(
    _ printer: inout CodePrinter, _ decl: ImportedNominalType, body: (inout CodePrinter) -> Void
  ) {
    if decl.swiftNominal.isSendable {
      printer.print("@ThreadSafe // Sendable")
    }
    printer.printBraceBlock("public final class \(decl.swiftNominal.name) extends JNISwiftInstance") { printer in
      body(&printer)
    }
  }

  private func printModuleClass(_ printer: inout CodePrinter, body: (inout CodePrinter) -> Void) {
    printer.printBraceBlock("public final class \(swiftModuleName)") { printer in
      body(&printer)
    }
  }

  private func printEnumHelpers(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    // TODO: Move this to seperate file +Enum?
    printEnumDiscriminator(&printer, decl)
    printer.println()
    printEnumStaticInitializers(&printer, decl)
  }

  private func printEnumDiscriminator(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    printer.printBraceBlock("public enum Discriminator") { printer in
      printer.print(
        decl.cases.map { $0.name.uppercased() }.joined(separator: ",\n")
      )
    }
  }

  private func printEnumStaticInitializers(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    for enumCase in decl.cases {
      printFunctionDowncallMethods(&printer, enumCase.caseFunction)
    }
  }

  private func printFunctionDowncallMethods(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    guard translatedDecl(for: decl) != nil else {
      // Failed to translate. Skip.
      return
    }

    printer.printSeparator(decl.displayName)

    printJavaBindingWrapperHelperClass(&printer, decl)

    printJavaBindingWrapperMethod(&printer, decl)
  }

  /// Print the helper type container for a user-facing Java API.
  ///
  /// * User-facing functional interfaces.
  private func printJavaBindingWrapperHelperClass(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    let translated = self.translatedDecl(for: decl)!
    if translated.functionTypes.isEmpty {
      return
    }

    printer.printBraceBlock(
      """
      public static class \(translated.name)
      """
    ) { printer in
      for functionType in translated.functionTypes {
        printJavaBindingWrapperFunctionTypeHelper(&printer, functionType)
      }
    }
  }

  /// Print "wrapper" functional interface representing a Swift closure type.
  func printJavaBindingWrapperFunctionTypeHelper(
    _ printer: inout CodePrinter,
    _ functionType: TranslatedFunctionType
  ) {
    let apiParams = functionType.parameters.map({ $0.parameter.renderParameter() })

    printer.print(
        """
        @FunctionalInterface
        public interface \(functionType.name) {
          \(functionType.result.javaType) apply(\(apiParams.joined(separator: ", ")));
        }
        """
    )
  }

  private func printJavaBindingWrapperMethod(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    guard let translatedDecl = translatedDecl(for: decl) else {
      fatalError("Decl was not translated, \(decl)")
    }

    var modifiers = ["public"]
    if decl.isStatic || decl.isInitializer || !decl.hasParent {
      modifiers.append("static")
    }

    let translatedSignature = translatedDecl.translatedFunctionSignature
    let resultType = translatedSignature.resultType.javaType
    var parameters = translatedDecl.translatedFunctionSignature.parameters.map({ $0.parameter.renderParameter() })
    if translatedSignature.requiresSwiftArena {
      parameters.append("SwiftArena swiftArena$")
    }
    let throwsClause = decl.isThrowing ? " throws Exception" : ""

    var annotationsStr = translatedSignature.annotations.map({ $0.render() }).joined(separator: "\n")
    if !annotationsStr.isEmpty { annotationsStr += "\n" }

    let modifiersStr = modifiers.joined(separator: " ")
    let parametersStr = parameters.joined(separator: ", ")

    printDeclDocumentation(&printer, decl)
    printer.printBraceBlock(
      "\(annotationsStr)\(modifiersStr) \(resultType) \(translatedDecl.name)(\(parametersStr))\(throwsClause)"
    ) { printer in
      printDowncall(&printer, decl)
    }

    printNativeFunction(&printer, decl)
  }

  private func printNativeFunction(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    let translatedDecl = translatedDecl(for: decl)! // Will always call with valid decl
    let nativeSignature = translatedDecl.nativeFunctionSignature
    let resultType = nativeSignature.result.javaType
    var parameters = nativeSignature.parameters.flatMap(\.parameters)
    if let selfParameter = nativeSignature.selfParameter?.parameters {
      parameters += selfParameter
    }
    parameters += nativeSignature.result.outParameters

    let renderedParameters = parameters.map { javaParameter in
        "\(javaParameter.type) \(javaParameter.name)"
    }.joined(separator: ", ")

    printer.print("private static native \(resultType) \(translatedDecl.nativeFunctionName)(\(renderedParameters));")
  }

  private func printDowncall(
    _ printer: inout CodePrinter,
    _ decl: ImportedFunc
  ) {
    let translatedDecl = translatedDecl(for: decl)! // We will only call this method if we can translate the decl.
    let translatedFunctionSignature = translatedDecl.translatedFunctionSignature

    // Regular parameters.
    var arguments = [String]()
    for parameter in translatedFunctionSignature.parameters {
      let lowered = parameter.conversion.render(&printer, parameter.parameter.name)
      arguments.append(lowered)
    }

    // 'self' parameter.
    if let selfParameter = translatedFunctionSignature.selfParameter {
      let lowered = selfParameter.conversion.render(&printer, "this")
      arguments.append(lowered)
    }

    // Indirect return receivers
    for outParameter in translatedFunctionSignature.resultType.outParameters {
      printer.print("\(outParameter.type) \(outParameter.name) = \(outParameter.allocation.render());")
      arguments.append(outParameter.name)
    }

    //=== Part 3: Downcall.
    // TODO: If we always generate a native method and a "public" method, we can actually choose our own thunk names
    // using the registry?
    let downcall = "\(translatedDecl.parentName).\(translatedDecl.nativeFunctionName)(\(arguments.joined(separator: ", ")))"

    //=== Part 4: Convert the return value.
    if translatedFunctionSignature.resultType.javaType.isVoid {
      printer.print("\(downcall);")
    } else {
      let result = translatedFunctionSignature.resultType.conversion.render(&printer, downcall)
      printer.print("return \(result);")
    }
  }

  private func printDeclDocumentation(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    printer.print(
      """
      /**
      * Downcall to Swift:
      * {@snippet lang=swift :
      * \(decl.signatureString)
      * }
      */
      """
    )
  }

  /// Prints the destroy function for a `JNISwiftInstance`
  private func printDestroyFunction(_ printer: inout CodePrinter, _ type: ImportedNominalType) {
    printer.print("private static native void $destroy(long selfPointer);")

    let funcName = "$createDestroyFunction"
    printer.print("@Override")
    printer.printBraceBlock("protected Runnable \(funcName)()") { printer in
      printer.print(
        """
        long self$ = this.$memoryAddress();
        if (CallTraces.TRACE_DOWNCALLS) {
          CallTraces.traceDowncall("\(type.swiftNominal.name).\(funcName)",
              "this", this,
              "self", self$);
        }
        return new Runnable() {
          @Override
          public void run() {
            if (CallTraces.TRACE_DOWNCALLS) {
              CallTraces.traceDowncall("\(type.swiftNominal.name).$destroy", "self", self$);
            }
            \(type.swiftNominal.name).$destroy(self$);
          }
        };
        """
      )
    }
  }
}
