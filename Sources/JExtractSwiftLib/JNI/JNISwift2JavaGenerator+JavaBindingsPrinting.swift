//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

extension JNISwift2JavaGenerator {
  func writeExportedJavaSources() throws {
    var printer = CodePrinter()
    try writeExportedJavaSources(&printer)
  }

  package func writeExportedJavaSources(_ printer: inout CodePrinter) throws {
    for (_, ty) in analysis.importedTypes.sorted(by: { (lhs, rhs) in lhs.key < rhs.key }) {
      let filename = "\(ty.swiftNominal.name).java"
      logger.info("Printing contents: \(filename)")
      printImportedNominal(&printer, ty)

      if let outputFile = try printer.writeContents(
        outputDirectory: javaOutputDirectory,
        javaPackagePath: javaPackagePath,
        filename: filename
      ) {
        print("[swift-java] Generated: \(ty.swiftNominal.name.bold).java (at \(outputFile))")
      }
    }

    let filename = "\(self.swiftModuleName).java"
    logger.trace("Printing module class: \(filename)")
    printModule(&printer)

    if let outputFile = try printer.writeContents(
      outputDirectory: javaOutputDirectory,
      javaPackagePath: javaPackagePath,
      filename: filename
    ) {
      logger.info("[swift-java] Generated: \(self.swiftModuleName).java (at \(outputFile))")
    }
  }

  private func printModule(_ printer: inout CodePrinter) {
    printHeader(&printer)
    printPackage(&printer)

    printModuleClass(&printer) { printer in
      printer.print(
        """
        static final String LIB_NAME = "\(swiftModuleName)";
        
        static {
          System.loadLibrary(LIB_NAME);
        }
        """
      )

      for decl in analysis.importedGlobalFuncs {
        self.logger.trace("Print global function: \(decl)")
        printFunctionBinding(&printer, decl)
        printer.println()
      }
    }
  }

  private func printImportedNominal(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    printHeader(&printer)
    printPackage(&printer)

    printNominal(&printer, decl) { printer in
      printer.print(
        """
        private long selfPointer;
        
        private \(decl.swiftNominal.name)(long selfPointer) {
          this.selfPointer = selfPointer;
        }
        """
      )

      for initializer in decl.initializers {
        printInitializerBindings(&printer, initializer, type: decl)
      }

      for method in decl.methods {
        printFunctionBinding(&printer, method)
      }
    }
  }

  private func printHeader(_ printer: inout CodePrinter) {
    printer.print(
      """
      // Generated by jextract-swift
      // Swift module: \(swiftModuleName)

      """
    )
  }

  private func printPackage(_ printer: inout CodePrinter) {
    printer.print(
      """
      package \(javaPackage);

      """
    )
  }

  private func printNominal(
    _ printer: inout CodePrinter, _ decl: ImportedNominalType, body: (inout CodePrinter) -> Void
  ) {
    printer.printBraceBlock("public final class \(decl.swiftNominal.name)") { printer in
      body(&printer)
    }
  }

  private func printModuleClass(_ printer: inout CodePrinter, body: (inout CodePrinter) -> Void) {
    printer.printBraceBlock("public final class \(swiftModuleName)") { printer in
      body(&printer)
    }
  }

  private func printFunctionBinding(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    printDeclDocumentation(&printer, decl)
    printer.print(
      "public static native \(renderFunctionSignature(decl));"
    )
  }

  private func printInitializerBindings(_ printer: inout CodePrinter, _ decl: ImportedFunc, type: ImportedNominalType) {
    let translatedDecl = translatedDecl(for: decl)

    printDeclDocumentation(&printer, decl)
    printer.printBraceBlock("public static \(renderFunctionSignature(decl))") { printer in
      let initArguments = translatedDecl.translatedFunctionSignature.parameters.map(\.asArgument)
      printer.print(
        """
        long selfPointer = \(type.qualifiedName).allocatingInit(\(initArguments.joined(separator: ", ")));
        return new \(type.qualifiedName)(selfPointer);
        """
      )
    }

    let parameters = translatedDecl.translatedFunctionSignature.parameters.map(\.asParameter)
    printer.print("private static native long allocatingInit(\(parameters.joined(separator: ", ")));")
  }

  private func printDeclDocumentation(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    printer.print(
      """
      /**
      * Downcall to Swift:
      * {@snippet lang=swift :
      * \(decl.signatureString)
      * }
      */
      """
    )
  }

  /// Renders a Java function signature
  ///
  /// `func method(x: Int, y: Int) -> Int` becomes
  /// `long method(long x, long y)`
  private func renderFunctionSignature(_ decl: ImportedFunc) -> String {
    let translatedDecl = translatedDecl(for: decl)
    let resultType = translatedDecl.translatedFunctionSignature.resultType
    let parameters = translatedDecl.translatedFunctionSignature.parameters.map(\.asParameter)
    let throwsClause = decl.isThrowing ? " throws Exception" : ""

    return "\(resultType) \(translatedDecl.name)(\(parameters.joined(separator: ", ")))\(throwsClause)"
  }
}
