//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//


// MARK: Defaults

extension JNISwift2JavaGenerator {
  /// Default set Java imports for every generated file
  static let defaultJavaImports: Array<String> = [
    "org.swift.swiftkit.core.*",
    "org.swift.swiftkit.core.util.*",
  ]
}

// MARK: Printing

extension JNISwift2JavaGenerator {
  func writeExportedJavaSources() throws {
    var printer = CodePrinter()
    try writeExportedJavaSources(&printer)
  }

  package func writeExportedJavaSources(_ printer: inout CodePrinter) throws {
    for (_, ty) in analysis.importedTypes.sorted(by: { (lhs, rhs) in lhs.key < rhs.key }) {
      let filename = "\(ty.swiftNominal.name).java"
      logger.info("Printing contents: \(filename)")
      printImportedNominal(&printer, ty)

      if let outputFile = try printer.writeContents(
        outputDirectory: javaOutputDirectory,
        javaPackagePath: javaPackagePath,
        filename: filename
      ) {
        logger.info("[swift-java] Generated: \(ty.swiftNominal.name.bold).java (at \(outputFile))")
      }
    }

    let filename = "\(self.swiftModuleName).java"
    logger.trace("Printing module class: \(filename)")
    printModule(&printer)

    if let outputFile = try printer.writeContents(
      outputDirectory: javaOutputDirectory,
      javaPackagePath: javaPackagePath,
      filename: filename
    ) {
      logger.info("[swift-java] Generated: \(self.swiftModuleName).java (at \(outputFile))")
    }
  }

  private func printModule(_ printer: inout CodePrinter) {
    printHeader(&printer)
    printPackage(&printer)

    printModuleClass(&printer) { printer in
      printer.print(
        """
        static final String LIB_NAME = "\(swiftModuleName)";
        
        static {
          System.loadLibrary(LIB_NAME);
        }
        """
      )

      for decl in analysis.importedGlobalFuncs {
        self.logger.trace("Print global function: \(decl)")
        printFunctionBinding(&printer, decl)
        printer.println()
      }

      for decl in analysis.importedGlobalVariables {
        printFunctionBinding(&printer, decl)
        printer.println()
      }
    }
  }

  private func printImportedNominal(_ printer: inout CodePrinter, _ decl: ImportedNominalType) {
    printHeader(&printer)
    printPackage(&printer)
    printImports(&printer)

    printNominal(&printer, decl) { printer in
      printer.print(
        """
        static final String LIB_NAME = "\(swiftModuleName)";
        
        @SuppressWarnings("unused")
        private static final boolean INITIALIZED_LIBS = initializeLibs();
        static boolean initializeLibs() {
            System.loadLibrary(LIB_NAME);
            return true;
        }
        """
      )

      printer.print(
        """
        public \(decl.swiftNominal.name)(long selfPointer, SwiftArena swiftArena) {
          super(selfPointer, swiftArena);
        }
        """
      )

      printer.println()

      for initializer in decl.initializers {
        printInitializerBindings(&printer, initializer, type: decl)
        printer.println()
      }

      for method in decl.methods {
        printFunctionBinding(&printer, method)
        printer.println()
      }

      for variable in decl.variables {
        printFunctionBinding(&printer, variable)
        printer.println()
      }

      printDestroyFunction(&printer, decl)
    }
  }

  private func printHeader(_ printer: inout CodePrinter) {
    printer.print(
      """
      // Generated by jextract-swift
      // Swift module: \(swiftModuleName)

      """
    )
  }

  private func printPackage(_ printer: inout CodePrinter) {
    printer.print(
      """
      package \(javaPackage);

      """
    )
  }

  private func printImports(_ printer: inout CodePrinter) {
    for i in JNISwift2JavaGenerator.defaultJavaImports {
      printer.print("import \(i);")
    }
    printer.print("")
  }

  private func printNominal(
    _ printer: inout CodePrinter, _ decl: ImportedNominalType, body: (inout CodePrinter) -> Void
  ) {
    printer.printBraceBlock("public final class \(decl.swiftNominal.name) extends JNISwiftInstance") { printer in
      body(&printer)
    }
  }

  private func printModuleClass(_ printer: inout CodePrinter, body: (inout CodePrinter) -> Void) {
    printer.printBraceBlock("public final class \(swiftModuleName)") { printer in
      body(&printer)
    }
  }

  private func printFunctionBinding(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    guard let _ = translatedDecl(for: decl) else {
      // Failed to translate. Skip.
      return
    }

    if decl.isStatic || decl.isInitializer || !decl.hasParent {
      printStaticFunctionBinding(&printer, decl)
    } else {
      printMemberMethodBindings(&printer, decl)
    }
  }

  private func printStaticFunctionBinding(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    printDeclDocumentation(&printer, decl)
    printer.print(
      "public static native \(renderFunctionSignature(decl));"
    )
  }

  /// Renders Java bindings for member methods
  ///
  /// Member methods are generated as a function that extracts the `selfPointer`
  /// and passes it down to another native function along with the arguments
  /// to call the Swift implementation.
  private func printMemberMethodBindings(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    let translatedDecl = translatedDecl(for: decl)! // We will only call this method if we can translate the decl.

    printDeclDocumentation(&printer, decl)
    printer.printBraceBlock("public \(renderFunctionSignature(decl))") { printer in
      var arguments = translatedDecl.translatedFunctionSignature.parameters.map(\.name)

      let selfVarName = "self$"
      arguments.append(selfVarName)

      let returnKeyword = translatedDecl.translatedFunctionSignature.resultType.isVoid ? "" : "return "

      printer.print(
        """
        long \(selfVarName) = this.$memoryAddress();
        \(returnKeyword)\(translatedDecl.parentName).$\(translatedDecl.name)(\(arguments.joined(separator: ", ")));
        """
      )
    }

    let returnType = translatedDecl.translatedFunctionSignature.resultType
    var parameters = translatedDecl.translatedFunctionSignature.parameters.map(\.asParameter)
    parameters.append("long selfPointer")
    printer.print("private static native \(returnType) $\(translatedDecl.name)(\(parameters.joined(separator: ", ")));")
  }

  private func printInitializerBindings(_ printer: inout CodePrinter, _ decl: ImportedFunc, type: ImportedNominalType) {
    guard let translatedDecl = translatedDecl(for: decl) else {
      // Failed to translate. Skip.
      return
    }

    printDeclDocumentation(&printer, decl)
    printer.printBraceBlock("public static \(renderFunctionSignature(decl))") { printer in
      let initArguments = translatedDecl.translatedFunctionSignature.parameters.map(\.name)
      printer.print(
        """
        long self$ = \(type.qualifiedName).allocatingInit(\(initArguments.joined(separator: ", ")));
        return new \(type.qualifiedName)(self$, swiftArena$);
        """
      )
    }

    let parameters = translatedDecl.translatedFunctionSignature.parameters.map(\.asParameter)
    printer.print("private static native long allocatingInit(\(parameters.joined(separator: ", ")));")
  }

  private func printDeclDocumentation(_ printer: inout CodePrinter, _ decl: ImportedFunc) {
    printer.print(
      """
      /**
      * Downcall to Swift:
      * {@snippet lang=swift :
      * \(decl.signatureString)
      * }
      */
      """
    )
  }

  /// Prints the destroy function for a `JNISwiftInstance`
  private func printDestroyFunction(_ printer: inout CodePrinter, _ type: ImportedNominalType) {
    printer.print("private static native void $destroy(long selfPointer);")

    let funcName = "$createDestroyFunction"
    printer.print("@Override")
    printer.printBraceBlock("protected Runnable \(funcName)()") { printer in
      printer.print(
        """
        long self$ = this.$memoryAddress();
        if (CallTraces.TRACE_DOWNCALLS) {
          CallTraces.traceDowncall("\(type.swiftNominal.name).\(funcName)",
              "this", this,
              "self", self$);
        }
        return new Runnable() {
          @Override
          public void run() {
            if (CallTraces.TRACE_DOWNCALLS) {
              CallTraces.traceDowncall("\(type.swiftNominal.name).$destroy", "self", self$);
            }
            \(type.swiftNominal.name).$destroy(self$);
          }
        };
        """
      )
    }
  }

  /// Renders a Java function signature
  ///
  /// `func method(x: Int, y: Int) -> Int` becomes
  /// `long method(long x, long y)`
  private func renderFunctionSignature(_ decl: ImportedFunc) -> String {
    guard let translatedDecl = translatedDecl(for: decl) else {
      fatalError("Unable to render function signature for a function that cannot be translated: \(decl)")
    }
    let resultType = translatedDecl.translatedFunctionSignature.resultType
    var parameters = translatedDecl.translatedFunctionSignature.parameters.map(\.asParameter)

    if decl.isInitializer {
      parameters.append("SwiftArena swiftArena$")
    }

    let throwsClause = decl.isThrowing ? " throws Exception" : ""

    return "\(resultType) \(translatedDecl.name)(\(parameters.joined(separator: ", ")))\(throwsClause)"
  }
}
