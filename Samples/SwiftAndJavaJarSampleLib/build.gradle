//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2024 Apple Inc. and the Swift.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//


import groovy.json.JsonSlurper
import org.swift.swiftkit.gradle.BuildUtils

import java.nio.file.*

plugins {
    id("build-logic.java-library-conventions")
    id "com.google.osdetector" version "1.7.3"
    id("maven-publish")
}

group = "org.swift.swiftkit"
version = "1.0-SNAPSHOT"

def swiftBuildConfiguration() {
    "release"
}

repositories {
    mavenLocal()
    mavenCentral()
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(22))
    }
}

dependencies {
    implementation(project(':SwiftKit'))

    testImplementation(platform("org.junit:junit-bom:5.10.0"))
    testImplementation("org.junit.jupiter:junit-jupiter")
}

// This is for development, when we edit the Swift swift-java project, the outputs of the generated sources may change.
// Thus, we also need to watch and re-build the top level project.
def compileSwiftJExtractPlugin = tasks.register("compileSwiftJExtractPlugin", Exec) {
    description = "Rebuild the swift-java root project"

    inputs.file(new File(rootDir, "Package.swift"))
    inputs.dir(new File(rootDir, "Sources"))
    outputs.dir(new File(rootDir, ".build"))

    workingDir = rootDir
    commandLine "swift"
    args("build",
            "-c", swiftBuildConfiguration(),
            "--product", "SwiftKitSwift",
            "--product", "JExtractSwiftPlugin",
            "--product", "JExtractSwiftCommandPlugin")
}

def jextract = tasks.register("jextract", Exec) {
    description = "Builds swift sources, including swift-java source generation"
    dependsOn compileSwiftJExtractPlugin

    // only because we depend on "live developing" the plugin while using this project to test it
    inputs.file(new File(rootDir, "Package.swift"))
    inputs.dir(new File(rootDir, "Sources"))

    inputs.file(new File(projectDir, "Package.swift"))
    inputs.dir(new File(projectDir, "Sources"))

    // TODO: we can use package describe --type json to figure out which targets depend on JExtractSwiftPlugin and will produce outputs
    //       Avoid adding this directory, but create the expected one specifically for all targets
    //       which WILL produce sources because they have the plugin
    outputs.dir(layout.buildDirectory.dir("../.build/plugins/outputs/${layout.projectDirectory.asFile.getName().toLowerCase()}"))

    File baseSwiftPluginOutputsDir = layout.buildDirectory.dir("../.build/plugins/outputs/").get().asFile
    if (!baseSwiftPluginOutputsDir.exists()) {
        baseSwiftPluginOutputsDir.mkdirs()
    }
    Files.walk(layout.buildDirectory.dir("../.build/plugins/outputs/").get().asFile.toPath()).each {
        // Add any Java sources generated by the plugin to our sourceSet
        if (it.endsWith("JExtractSwiftPlugin/src/generated/java")) {
            outputs.dir(it)
        }
    }

    workingDir = layout.projectDirectory
    commandLine "swift"
    args("package", "jextract", "-v", "--log-level", "info") // TODO: pass log level from Gradle build
}


// Add the java-swift generated Java sources
sourceSets {
    main {
        java {
            srcDir(jextract)
        }
    }
    test {
        java {
            srcDir(jextract)
        }
    }
}

tasks.build {
    dependsOn("jextract")
}

tasks.named('test', Test) {
    useJUnitPlatform()
}


// ==== Jar publishing

List<String> swiftProductDylibPaths() {

    def process = ['swift', 'package', 'describe', '--type', 'json'].execute()
    process.waitFor()

    if (process.exitValue() != 0) {
        throw new RuntimeException("[swift describe] command failed with exit code: ${process.exitValue()}. Cannot find products! Output: ${process.err.text}")
    }

    def json = new JsonSlurper().parseText(process.text)

    // TODO: require that we depend on swift-java
    // TODO: all the products where the targets depend on swift-java plugin
    def products =
            json.targets.collect { target ->
                target.product_memberships
            }.flatten()



    def productDylibPaths = products.collect {
        logger.info("[swift-java] Include Swift product: '${it}' in product resource paths.")
        "${layout.projectDirectory}/.build/${swiftBuildConfiguration()}/lib${it}.dylib"
    }

    return productDylibPaths
}

processResources {
    dependsOn "jextract"

    def dylibs = [
        "${layout.projectDirectory}/.build/${swiftBuildConfiguration()}/libSwiftKitSwift.dylib"
    ]
    dylibs.addAll(swiftProductDylibPaths())
    from(dylibs)
}

jar {
    archiveClassifier = osdetector.classifier
}

base {
    archivesName = "swift-and-java-jar-sample-lib"
}

publishing {
    publications {
        maven(MavenPublication) {
            artifactId = "swift-and-java-jar-sample-lib"
            from components.java
        }
    }
    repositories {
        mavenLocal()
    }
}
