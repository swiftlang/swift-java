//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2024 Apple Inc. and the Swift.org project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift.org project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import groovy.json.JsonSlurper
import org.swift.swiftkit.gradle.BuildUtils

import java.nio.file.*

plugins {
    id("build-logic.java-application-conventions")
    id("me.champeau.jmh") version "0.7.2"
}

group = "org.swift.swiftkit"
version = "1.0-SNAPSHOT"

repositories {
    mavenCentral()
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(24))
    }
}

def swiftProductsWithJExtractPlugin() {
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()

    def result = exec {
        commandLine 'swift', 'package', 'describe', '--type', 'json'
        standardOutput = stdout
        errorOutput = stderr
        ignoreExitValue = true
    }

    def jsonOutput = stdout.toString()

    if (result.exitValue == 0) {
        def json = new JsonSlurper().parseText(jsonOutput)
        def products = json.targets
                .findAll { target ->
                    target.product_dependencies?.contains("JExtractSwiftPlugin")
                }
                .collectMany { target ->
                    target.product_memberships ?: []
                }
        return products
    } else {
        logger.warn("Command failed: ${stderr.toString()}")
        return []
    }
}


def swiftCheckValid = tasks.register("swift-check-valid", Exec) {
    commandLine "swift"
    args("-version")
}

def jextract = tasks.register("jextract", Exec) {
    description = "Generate Java wrappers for swift target"
    dependsOn swiftCheckValid

    // only because we depend on "live developing" the plugin while using this project to test it
    inputs.file(new File(rootDir, "Package.swift"))
    inputs.dir(new File(rootDir, "Sources"))

    // If the package description changes, we should execute jextract again, maybe we added jextract to new targets
    inputs.file(new File(projectDir, "Package.swift"))

    // monitor all targets/products which depend on the JExtract plugin
    swiftProductsWithJExtractPlugin().each {
        logger.info("[swift-java:jextract (Gradle)] Swift input target: ${it}")
        inputs.dir(new File(layout.projectDirectory.asFile, "Sources/${it}".toString()))
    }
    outputs.dir(layout.buildDirectory.dir("../.build/plugins/outputs/${layout.projectDirectory.asFile.getName().toLowerCase()}"))

    File baseSwiftPluginOutputsDir = layout.buildDirectory.dir("../.build/plugins/outputs/").get().asFile
    if (!baseSwiftPluginOutputsDir.exists()) {
        baseSwiftPluginOutputsDir.mkdirs()
    }
    Files.walk(layout.buildDirectory.dir("../.build/plugins/outputs/").get().asFile.toPath()).each {
        // Add any Java sources generated by the plugin to our sourceSet
        if (it.endsWith("JExtractSwiftPlugin/src/generated/java")) {
            outputs.dir(it)
        }
    }

    workingDir = layout.projectDirectory
    commandLine "swift"
    args("build") // since Swift targets which need to be jextract-ed have the jextract build plugin, we just need to build
    // If we wanted to execute a specific subcommand, we can like this:
    //     args("run",/*
    //             "swift-java", "jextract",
    //             "--swift-module", "MySwiftLibrary",
    //             // java.package is obtained from the swift-java.config in the swift module
    //             "--output-java", "${layout.buildDirectory.dir(".build/plugins/outputs/${layout.projectDirectory.asFile.getName().toLowerCase()}/JExtractSwiftPlugin/src/generated/java").get()}",
    //             "--output-swift", "${layout.buildDirectory.dir(".build/plugins/outputs/${layout.projectDirectory.asFile.getName().toLowerCase()}/JExtractSwiftPlugin/Sources").get()}",
    //             "--log-level", (logging.level <= LogLevel.INFO ? "debug" :  */"info")
    //     )
}

// Add the java-swift generated Java sources
sourceSets {
    main {
        java {
            srcDir(jextract)
        }
    }
    test {
        java {
            srcDir(jextract)
        }
    }
    jmh {
        java {
            srcDir(jextract)
        }
    }
}

tasks.build {
    dependsOn("jextract")
}


def cleanSwift = tasks.register("cleanSwift", Exec) {
    workingDir = layout.projectDirectory
    commandLine "swift"
    args("package", "clean")
}
tasks.clean {
    dependsOn("cleanSwift")
}

dependencies {
    implementation(project(':SwiftKitCore'))
    implementation(project(':SwiftKitFFM'))

    testImplementation(platform("org.junit:junit-bom:5.10.0"))
    testImplementation("org.junit.jupiter:junit-jupiter")
}

tasks.named('test', Test) {
    useJUnitPlatform()
}

application {
    mainClass = "com.example.swift.HelloJava2Swift"

    applicationDefaultJvmArgs = [
        "--enable-native-access=ALL-UNNAMED",

        // Include the library paths where our dylibs are that we want to load and call
        "-Djava.library.path=" +
                (BuildUtils.javaLibraryPaths(rootDir) +
                 BuildUtils.javaLibraryPaths(project.projectDir)).join(":"),


        // Enable tracing downcalls (to Swift)
        "-Djextract.trace.downcalls=true"
    ]
}

String jmhIncludes = findProperty("jmhIncludes")

jmh {
    if (jmhIncludes != null) {
        includes = [jmhIncludes]
    }

    jvmArgsAppend = [
        "--enable-native-access=ALL-UNNAMED",

        "-Djava.library.path=" +
                (BuildUtils.javaLibraryPaths(rootDir) +
                 BuildUtils.javaLibraryPaths(project.projectDir)).join(":"),

        // Enable tracing downcalls (to Swift)
        "-Djextract.trace.downcalls=false"
    ]
}
